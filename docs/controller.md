---
title: Controller
layout: default
---

# Controller

> NOTE: this is a documentation for 5.2.0 and above. please visit this [document for 5.1 and below](controller.5.1.md).

Wallaby resources controller is just an ordinary Rails controller that has implemented default resourcesful actions for all its subclasses. Therefore, customization becomes as simple as overriding the existing actions.

First of all, it's always recommended to create a base controller class `Admin::ApplicationController`, so that devs have better control of global changes/functions:

```ruby
# app/controllers/admin/application_controller.rb
class Admin::ApplicationController < Wallaby::ResourcesController
end
```

This base controller can be generated by Wallaby generator as well (since 5.2.0):

```shell
rails g wallaby:install
```

> See [resources_controller configuration](configuration.md#controller) if `Admin::ApplicationController` is taken for other purpose.

> NOTE: `Admin::ApplicationController` has access to all methods in `::ApplicationController`. Because its parent `Wallaby::ResourcesController` inherits from `::ApplicationController` unless this is changed in Wallaby [base_controller configuration](configuration.md#base_controller).

Starting with:

- [Create a controller](#declaration) to do customization at controller level.

Configuration can be set for:

- [.base_class!](#base_class) (since 5.2.0) - marks current controller class as base class.
- [.namespace](#namespace) (since 5.2.0) - specifies the namespace for current controller class and its subclasses so that their model classes can be retrived correctly.
- [.model_class](#model_class) - specifies the associated model class for current controller class.

The following resourcesful actions can be customized:

- [index](#index) - lists the collection of resources.
- [new](#new) - displays resource creation form.
- [create](#create) - handles resource creation.
- [show](#show) - displays single resource.
- [edit](#edit) - displays resource edit form.
- [update](#update) - handles resource update.
- [destroy](#destroy) - handles resource deletion.

For non-resourcesful actions:

- [home](#home) (since 5.1.0) - works as the landing page action.

And it is possible:

- [authenticate_user!](#authenticate_user) - authenticates the current user.
- [wallaby_user](#wallaby_user) - returns the object for the signed-in user.
- [collection](#collection) - returns the paginated collection.
- [resource](#resource) - returns the resource by given ID.
- [resource_params](#resource_params) - returns the white-listed parameters for mass assignment.

Other configuration:

- [.theme_name](#theme_name) (since 5.2.0) - specifies the theme and layout for current controller class and its subclasses.
- [.resource_decorator](#resource_decorator) - specifies the associated resource decorator class for current controller class.
- [.model_servicer](#model_servicer) - specifies the associated model servicer class for current controller class.
- [.model_authorizer](#model_authorizer) (since 5.2.0) - specifies the associated model authorizer class for current controller class.
- [.model_paginator](#model_paginator) (since 5.2.0) - specifies the associated model paginator class for current controller class.

More advanced configuration:

- [.engine_name](#engine_name) (since 5.2.0) - specifies the name of engine helper for current controller class and its subclasses.
- [.application_decorator](#application_decorator) (since 5.2.0) - specifies the associated base resource decorator class for current controller class and its subclasses.
- [.application_servicer](#application_servicer) (since 5.2.0) - specifies the associated base model servicer class for current controller class and its subclasses.
- [.application_authorizer](#application_authorizer) (since 5.2.0) - specifies the associated base model authorizer class for current controller class and its subclasses.
- [.application_paginator](#application_paginator) (since 5.2.0) - specifies the associated base model paginator class for current controller class and its subclasses.

## Create a controller

> Read more at [Controller Naming Convention](convention.md#controller)

To do customization at controller level for a model (e.g. `Product`), it is required to create a controller to inherit from the [above](#controller) base class [Admin::ApplicationController](#controller):

```ruby
# app/controllers/admin/products_controller.rb
class Admin::ProductsController < Admin::ApplicationController
end
```

Then the customization will be as simple as overriding the below default resourcesful actions ([index](#index), [new](#new), [create](#create), [show](#show), [edit](#edit), [update](#update) and [destroy](#destroy)).

# Configuration

## .base_class!

> since 5.2.0

All controllers will be preloaded and processed by Wallaby in order to build up the mapping between controllers and models. If the controller is considered not to be processed, it can be flagged as abstract by using `base_class!`:

```ruby
# app/controllers/admin/special_controller.rb
class Admin::SpecialController < Admin::ApplicationController
  base_class!
end
```

## .namespace

> since 5.2.0

Wallaby automatically retrieves the namespace for base class `Admin::ApplicationController` as `Admin`:

```ruby
Admin::ApplicationController.namespace
# => 'Admin'
```

Then all its subclasses can apply the same namespace to retrieve the model class correctly, for example:

```ruby
Admin::ProductsController.namespace
# => 'Admin'
Admin::ProductsController.model_class
# => Product

Admin::Order::ItemsController.namespace
# => 'Admin'
Admin::Order::ItemsController.model_class
# => Order::Item
```

If the base class is different (e.g. `GlobalController`), a namespace can be configured so that all its `Admin` namespaced subclasses can retrieve the correct model class:

```ruby
class GlobalController < Wallaby::ResourcesController
  self.namespace = 'Admin'
end

class Admin::CustomersController < GlobalController
end

Admin::CustomersController.namespace
# => 'Admin'
Admin::CustomersController.model_class
# => Customer
```

## .model_class

According to Wallaby's [Controller Naming Convention](convention.md#controller), if a custom controller cannot reflect its associated model, e.g. `Admin::GoodsController` and `Product`, model class should be specified for the controller to work properly:

```ruby
# app/controllers/admin/goods_controller.rb
class Admin::GoodsController < Admin::ApplicationController
  self.model_class = Product
end
```

# Actions

## index

To add functionality to the index action, override it with super method `index!`:

```ruby
def index
  # do something before the origin action
  index! do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def index(options = {}, &block)
  current_authorizer.authorize :index, current_model_class
  respond_with collection, options, &block
end
```

And it can be replaced completely:

```ruby
def index
  @collection = Product.all
end
```

> NOTE: `@collection` MUST be assigned, because it's used by the view.

## new

To add functionality to the new action, override it with super method `new!`:

```ruby
def new
  # do something before the origin action
  new! do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def new(options = {}, &block)
  current_authorizer.authorize :new, resource
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def new
  @resource = Product.new new_arrival: true
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## create

> NOTE: `create` action works differently since 5.2.0, it assigns the params when servicer performs `create`. But for version 5.1 and below, it assigns the params before servicer performs `create`.

To add functionality to the create action, override it with super method `create!`:

```ruby
def create
  # do something before the origin action
  create!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def create(options = {}, &block)
  set_defaults_for :create, options
  current_authorizer.authorize :create, resource
  current_servicer.create resource, options.delete(:params)
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def create
  @resource = Product.create(resource_params.merge new_arrival: true)
  redirect_to @resource
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## show

To add functionality to the show action, override it with super method `show!`:

```ruby
def show
  # do something before the origin action
  show! do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def show(options = {}, &block)
  current_authorizer.authorize :show, resource
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def show
  @resource = Product.friendly.find params[:id]
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## edit

To add functionality to the edit action, override it with super method `edit!`:

```ruby
def edit
  # do something before the origin action
  edit! do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def edit(options = {}, &block)
  current_authorizer.authorize :edit, resource
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def edit
  @resource = Product.friendly.find params[:id]
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## update

> NOTE: `update` action works differently since 5.2.0, it assigns the params when servicer performs `update`. But for version 5.1 and below, it assigns the params before servicer performs `update`.

To add functionality to the update action, override it with super method `update!`:

```ruby
def update
  # do something before the origin action
  update!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def update(options = {}, &block)
  set_defaults_for :update, options
  current_authorizer.authorize :update, resource
  current_servicer.update resource, options.delete(:params)
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def update
  @resource = Product.friendly.find params[:id]
  @resource.update resource_params
  redirect_to @resource
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## destroy

To add functionality to the destroy action, override it with super method `destroy!`:

```ruby
def destroy
  # do something before the origin action
  destroy!(
    params: nil, # params to use for the servicer
    location: nil # where to redirect when successful
  ) do |format| # `respond_with` block
    # do something here before rendering
  end
end
```

Basically, the implementation is as simple as:

```ruby
def destroy(options = {}, &block)
  set_defaults_for :destroy, options
  current_authorizer.authorize :destroy, resource
  current_servicer.destroy resource, options.delete(:params)
  respond_with resource, options, &block
end
```

And it can be replaced completely:

```ruby
def destroy
  @resource = Product.friendly.find params[:id]
  @resource.destroy
  redirect_to @resource
end
```

## home

> since 5.1.0

This is the landing page of the Wallaby Admin Interface (when Wallaby engine is mounted).

Basically, it does nothing as:

```ruby
def home
  # do nothing
end
```

It can be replaced completely in the base controller class (e.g. [Admin::ApplicationController](#controller)):

```ruby
def home
  @reports = build_reports
end
```

# Methods

## authenticate_user!

This is the method that Wallaby uses for authentication to check if user has signed in or not.

To customize, override it:

```ruby
def authenticate_user!
  # http basic authentication
  authenticate_or_request_with_http_basic do |username, password|
    username == 'too_simple' && password == 'too_naive'
  end
end
```

Or it can be customized via [authenticate_user configuration](configuration.md#authenticate_user-and-current_user).

## wallaby_user

This is the method that Wallaby uses to return the object of the signed-in user.

> NOTE: it is also a helper method available in the view.

To customize, override it:

```ruby
def wallaby_user
  # user example
  @wallaby_user ||= Class.new do
    def email
      'user@example.com'
    end
  end.new
end
```

Or it can be customized via [current_user configuration](configuration.md#authenticate_user-and-current_user).

## collection

This is the method to return the collection for index page to display.

> NOTE: it is also a helper method available in the view.

> NOTE: pagination should be done in this method as well.

To add functionality, override it with super method `collection!`:

```ruby
def collection
  collection!(
    params: nil, # params to use for the servicer
    paginate: true # whether to paginate the collection
  ) do |records|
    # do something here after origin query is completed
    # but before `@collection` instance variable is set
    records
  end
end
```

Or it can be replaced completely:

```ruby
def collection
  @collection ||= Product.new_arrival.page(params[:page]).per(params[:per])
end
```

> NOTE: `@collection` MUST be assigned, because it's used by the view.

## resource

This is the method to return the resource for [new](#new), [create](#create), [show](#show), [edit](#edit), [update](#update) and [destroy](#destroy) action.

> NOTE: it is also a helper method available in the view.

> NOTE: the resource returned will be either persisted or unpersisted depending on the action.

To add functionality, override it with super method `resource!`:

```ruby
def resource
  resource!(
    find_params: nil, # params/options for servicer's `find` action
    new_params: nil # params/options for servicer's `new` action
  ) do |record|
    # do something here after origin query is completed
    # but before `@resource` instance variable is set
    record
  end
end
```

Or it can be replaced completely:

```ruby
def resource
  @resource ||= Product.new_arrival
end
```

> NOTE: `@resource` MUST be assigned, because it's used by the view.

## resource_params

This is the method that returns the parameters for mass assignment for [create](#create) and [update](#update) action.

Basically, the implementation is as simple as:

```ruby
def resource_params
  @resource_params ||= current_servicer.permit params, action_name
end
```

To customize, override it:

```ruby
def resource_params
  params.require(:product).permit(:name, :sku)
end
```

# More Configuration

## .theme_name

A theme is a set of view layout and templates that follow [Layout Inheritance](https://guides.rubyonrails.org/layouts_and_rendering.html#layout-inheritance) and [Template Inheritance](https://guides.rubyonrails.org/layouts_and_rendering.html#template-inheritance).

> Read more at [Theme](theme.md).

To apply a theme, it simply goes:

```ruby
# app/controllers/admin/application_controller.rb
class Admin::ApplicationController < Wallaby::ResourcesController
  self.theme_name = 'bootstrap4'
end
```

## .resource_decorator

Wallaby should be able to pick the appropriate [resource decorator](decorator.md) for current controller. However, if Wallaby doesn't get it right, resource decorator can be configured as below:

```ruby
class Admin::ProductDecorator < Admin::ApplicationDecorator
end

class ProductDecorator < Admin::ApplicationDecorator
end

class Admin::ProductsController < Admin::ApplicationController
  resource_decorator # => Admin::ProductDecorator
  self.resource_decorator = ProductDecorator
end
```

## .application_decorator

It is possible for a controller to nominate a different base decoraotr class so that the controller and its subclasses will use the same base decoraotr. For example:

```ruby
class SuperAdminDecorator < Wallaby::ResourceDecorator
  def owner_to_display
    super
  end
end

class AdvisorOnlyDecorator < Wallaby::ResourceDecorator
  def owner_to_display
    '<n/a>'
  end
end

class Admin::ApplicationController < Wallaby::ResourcesController
  application_decorator # nil
  self.application_decorator = SuperAdminDecorator
end
```

## .model_servicer

Wallaby should be able to pick the appropriate [model servicer](servicer.md) for current controller. However, if Wallaby doesn't get it right, model servicer can be configured as below:

```ruby
class Admin::ProductServicer < Admin::ApplicationServicer
end

class ProductServicer < Admin::ApplicationServicer
end

class Admin::ProductsController < Admin::ApplicationController
  model_servicer # => Admin::ProductServicer
  self.model_servicer = ProductServicer
end
```

## .application_servicer

It is possible for a controller to nominate a different base servicer class so that the controller and its subclasses will use the same base servicer. For example:

```ruby
class SuperAdminServicer < Wallaby::ModelServicer
  def create(resource, params)
    super resource, params.merge(admin: true)
  end
end

class AdvisorOnlyServicer < Wallaby::ModelServicer
  def create(resource, params)
    super resource, params.merge(admin: false)
  end
end

class Admin::ApplicationController < Wallaby::ResourcesController
  application_servicer # nil
  self.application_servicer = SuperAdminServicer
end
```

## .model_authorizer

Wallaby should be able to pick the appropriate [model authorizer](authorizer.md) for current controller. However, if Wallaby doesn't get it right, model authorizer can be configured as below:

```ruby
class Admin::ProductAuthorizer < Admin::ApplicationAuthorizer
end

class ProductAuthorizer < Admin::ApplicationAuthorizer
end

class Admin::ProductsController < Admin::ApplicationController
  model_authorizer # => Admin::ProductAuthorizer
  self.model_authorizer = ProductAuthorizer
end
```

## .application_authorizer

It is possible for a controller to nominate a different base authorizer class so that the controller and its subclasses will use the same base authorizer. For example:

```ruby
class SuperAdminAuthorizer < Wallaby::ModelAuthorizer
  def authorized?(action, subject)
    true
  end
end

class AdvisorOnlyAuthorizer < Wallaby::ModelAuthorizer
  def authorized?(action, subject)
    false
  end
end

class Admin::ApplicationController < Wallaby::ResourcesController
  application_authorizer # nil
  self.application_authorizer = SuperAdminAuthorizer
end
```

## .model_paginator

Wallaby should be able to pick the appropriate [model paginator](paginator.md) for current controller. However, if Wallaby doesn't get it right, model paginator can be configured as below:

```ruby
class Admin::ProductPaginator < Admin::ApplicationPaginator
end

class ProductPaginator < Admin::ApplicationPaginator
end

class Admin::ProductsController < Admin::ApplicationController
  model_paginator # => Admin::ProductPaginator
  self.model_paginator = ProductPaginator
end
```

## .application_paginator

It is possible for a controller to nominate a different base paginator class so that the controller and its subclasses will use the same base paginator. For example:

```ruby
class SuperAdminPaginator < Wallaby::ModelPaginator
  def authorized?(action, subject)
    true
  end
end

class AdvisorOnlyPaginator < Wallaby::ModelPaginator
  def authorized?(action, subject)
    false
  end
end

class Admin::ApplicationController < Wallaby::ResourcesController
  application_paginator # nil
  self.application_paginator = SuperAdminPaginator
end
```
